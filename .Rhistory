eFP1.res <- cuhre(NDIM, NCOMP, fun.eFP1, lower=intmar.l, upper=intmar.u, flags= list(verbose=0, final=0))
rcd.simuCI1.tmp1 <- eFP1.res$value
# two type of restricted CI:
rcd.simuCI1.tmp2 <- NA
rcd.simuCI1.tmp3 <- NA
# Why the if condition?
if(eFP1.res$value>p.level){
eFP1.int1 <- function(delta){
fun.eFP1t1 <- function(x){
refstd <- 1.5*sd.ref
indt <- ( abs(x[1]-x[2])<=refstd )*( abs(x[1]-x[3])<=delta )*( abs(x[2]-x[3])<=refstd )
fxyz <- dnorm(x[1], mean = mean.data[1], sd = sd.ref/sqrt(n))*
dnorm(x[2], mean = mean.data[2], sd = sd.ref/sqrt(n))*
dnorm(x[3], mean = mean.data[3], sd = sd.ref/sqrt(n))*indt
return(fxyz)
}
return(cuhre(NDIM, NCOMP, fun.eFP1t1, lower=intmar.l, upper=intmar.u, flags= list(verbose=0, final=0))$value)
}
rcd.simuCI1.tmp2 <- uniroot(function(delta) eFP1.int1(delta)-p.level, lower = 0, upper = 1.5*sd.ref)$root
eFP1.int2 <- function(delta){
fun.eFP1t2 <- function(x){
indt <- ( abs(x[1]-x[2])<=delta )*( abs(x[1]-x[3])<=delta )*( abs(x[2]-x[3])<=delta )
fxyz <- dnorm(x[1], mean = mean.data[1], sd = sd.ref/sqrt(n))*dnorm(x[2], mean = mean.data[2], sd = sd.ref/sqrt(n))*dnorm(x[3], mean = mean.data[3], sd = sd.ref/sqrt(n))*indt
return(fxyz)
}
return(cuhre(NDIM, NCOMP, fun.eFP1t2, lower=intmar.l, upper=intmar.u, flags= list(verbose=0, final=0))$value)
}
rcd.simuCI1.tmp3 <- uniroot(function(delta) eFP1.int2(delta)-p.level, lower = 0, upper = 20*sd.ref)$root
}
# 2.1.2 Integrated version, suppose population sd unknown and follow an inversed chisq distribution
intmarv <- sqrt((n-1)*sd.ref^2/qchisq(1-p.int,df=n-1)) # p.int=0.999, upper bound of the inversed chisq, UB for intergral interval of population sd
tmp1 <- sqrt((n-1)*sd.ref^2/qchisq(p.int1,df=n-1))
intmar.l.int  <- mean.data - qnorm(p.int)*tmp1/sqrt(n) # tmp1 seems not correct?
intmar.u.int  <- mean.data + qnorm(p.int)*tmp1/sqrt(n)
fun.eFP1.int <- function(x){
refstd <- 1.5*x[4]
indt <- ( abs(x[1]-x[2])<=refstd )*( abs(x[1]-x[3])<=refstd )*( abs(x[2]-x[3])<=refstd )
fxyzu <- dnorm(x[1], mean = mean.data[1], sd = x[4]/sqrt(n))*
dnorm(x[2], mean = mean.data[2], sd = x[4]/sqrt(n))*
dnorm(x[3], mean = mean.data[3], sd = x[4]/sqrt(n))*indt*
(2*x[4]^(-3)*(n-1)*sd.ref^2)*dchisq((n-1)*sd.ref^2/(x[4]^2), df=n-1)  # pdf of population sd through fiducial inference?
return(fxyzu)
}
eFP1.res.mod <- cuhre(NDIM+1, NCOMP, fun.eFP1.int, lower=c(intmar.l.int,0), upper=c(intmar.u.int,intmarv), flags= list(verbose=0, final=0))
rcd.simuCI1.tmp4 <- eFP1.res.mod$value
rcd.simuCI1.tmp5 <- NA
if(eFP1.res.mod$value>p.level){
eFP1.int1.mod <- function(delta){
fun.eFP1t1.mod <- function(x){
refstd <- 1.5*x[4]
indt <- ( abs(x[1]-x[2])<=refstd )*( abs(x[1]-x[3])<=delta*refstd )*( abs(x[2]-x[3])<=refstd )
fxyzu <- dnorm(x[1], mean = mean.data[1], sd = x[4]/sqrt(n))*
dnorm(x[2], mean = mean.data[2], sd = x[4]/sqrt(n))*
dnorm(x[3], mean = mean.data[3], sd = x[4]/sqrt(n))*indt*
(2*x[4]^(-3)*(n-1)*sd.ref^2)*dchisq((n-1)*sd.ref^2/(x[4]^2), df=n-1)
return(fxyzu)
}
return(cuhre(NDIM+1, NCOMP, fun.eFP1t1.mod, lower=c(intmar.l.int,0), upper=c(intmar.u.int,intmarv), flags= list(verbose=0, final=0))$value)
}
rcd.simuCI1.tmp5 <- uniroot(function(delta) eFP1.int1.mod(delta)-p.level, lower = 0, upper = 1)$root
eFP1.int2.mod <- function(delta){
fun.eFP1t2.mod <- function(x){
refstd <- 1.5*x[4]
indt <- ( abs(x[1]-x[2])<=delta*refstd )*( abs(x[1]-x[3])<=delta*refstd )*( abs(x[2]-x[3])<=delta*refstd )
fxyzu <- dnorm(x[1], mean = mean.data[1], sd = x[4]/sqrt(n))*
dnorm(x[2], mean = mean.data[2], sd = x[4]/sqrt(n))*
dnorm(x[3], mean = mean.data[3], sd = x[4]/sqrt(n))*indt*
(2*x[4]^(-3)*(n-1)*sd.ref^2)*dchisq((n-1)*sd.ref^2/(x[4]^2), df=n-1)
return(fxyzu)
}
return(cuhre(NDIM+1, NCOMP, fun.eFP1t2.mod, lower=c(intmar.l.int,0), upper=c(intmar.u.int,intmarv), flags= list(verbose=0, final=0))$value)
}
rcd.simuCI1.tmp6 <- uniroot(function(delta) eFP1.int2.mod(delta)-p.level, lower = 0, upper = 20)$root
}
# 2.1.3 Least favorable version, suppose population sd take the lower bound of the inversed chisq distribution
sd.ref.lf <- sqrt((n-1)*sd.ref^2/qchisq(1 - alpha,df=n-1)) # lower bound of the inversed chisq
intmar.l.lf <- mean.data - qnorm(p.int)*sd.ref.lf/sqrt(n)
intmar.u.lf <- mean.data + qnorm(p.int)*sd.ref.lf/sqrt(n)
fun.eFP1.lf <- function(x){
refstd <- 1.5*sd.ref.lf
indt <- ( abs(x[1]-x[2])<=refstd )*( abs(x[1]-x[3])<=refstd )*( abs(x[2]-x[3])<=refstd )
fxyz <- dnorm(x[1], mean = mean.data[1], sd = sd.ref.lf/sqrt(n))*
dnorm(x[2], mean = mean.data[2], sd = sd.ref.lf/sqrt(n))*
dnorm(x[3], mean = mean.data[3], sd = sd.ref.lf/sqrt(n))*indt
return(fxyz)
}
eFP1.res.lf <- cuhre(NDIM, NCOMP, fun.eFP1.lf, lower=intmar.l.lf, upper=intmar.u.lf, flags= list(verbose=0, final=0))
rcd.simuCI1.tmp7 <- eFP1.res.lf$value
rcd.simuCI1.tmp8 <- NA
rcd.simuCI1.tmp9 <- NA
if(eFP1.res.lf$value>p.level){
eFP1.int1.lf <- function(delta){
fun.eFP1t1.lf <- function(x){
refstd <- 1.5*sd.ref.lf
indt <- ( abs(x[1]-x[2])<=refstd )*( abs(x[1]-x[3])<=delta )*( abs(x[2]-x[3])<=refstd )
fxyz <- dnorm(x[1], mean = mean.data[1], sd = sd.ref.lf/sqrt(n))*
dnorm(x[2], mean = mean.data[2], sd = sd.ref.lf/sqrt(n))*
dnorm(x[3], mean = mean.data[3], sd = sd.ref.lf/sqrt(n))*indt
return(fxyz)
}
return(cuhre(NDIM, NCOMP, fun.eFP1t1.lf, lower=intmar.l.lf, upper=intmar.u.lf, flags= list(verbose=0, final=0))$value)
}
rcd.simuCI1.tmp8 <- uniroot(function(delta) eFP1.int1.lf(delta)-p.level, lower = 0, upper = 1.5*sd.ref.lf)$root
eFP1.int2.lf <- function(delta){
fun.eFP1t2.lf <- function(x){
indt <- ( abs(x[1]-x[2])<=delta )*( abs(x[1]-x[3])<=delta )*( abs(x[2]-x[3])<=delta )
fxyz <- dnorm(x[1], mean = mean.data[1], sd = sd.ref.lf/sqrt(n))*
dnorm(x[2], mean = mean.data[2], sd = sd.ref.lf/sqrt(n))*
dnorm(x[3], mean = mean.data[3], sd = sd.ref.lf/sqrt(n))*indt
return(fxyz)
}
return(cuhre(NDIM, NCOMP, fun.eFP1t2.lf, lower=intmar.l.lf, upper=intmar.u.lf, flags= list(verbose=0, final=0))$value)
}
rcd.simuCI1.tmp9 <- uniroot(function(delta) eFP1.int2.lf(delta)-p.level, lower = 0, upper = 20*sd.ref.lf)$root
}
# 2.2 Without the assumption of equal variances, one reference (use sd.ref to calculate similarity margin: refstd=1.5*sd.ref)
# 2.2.1 Original version, sd.ref as true population sd
# dt(sqrt(n)*(x[]-mean.data[])/sd.data[],df=n-1)  n^(3/2)/prod(sd.data)
fun.ineFP1 <- function(x){
refstd <- 1.5*sd.ref
indt <- ( abs(x[1]-x[2])<=refstd )*( abs(x[1]-x[3])<=refstd )*( abs(x[2]-x[3])<=refstd )
fxyz <- dnorm(x[1], mean = mean.data[1], sd = sd.ref/sqrt(n))*
dt(sqrt(n)*(x[2]-mean.data[2])/sd.data[2],df=n-1)*
dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*n^(2/2)/prod(sd.data[2:3])*indt
return(fxyz)
}
ineFP1.res <- cuhre(NDIM, NCOMP, fun.ineFP1, lower=c(intmar.l[1],intmar.l.ie[2:3]), upper=c(intmar.u[1],intmar.u.ie[2:3]), flags= list(verbose=0, final=0))
rcd.simuCI2.tmp1 <- ineFP1.res$value
rcd.simuCI2.tmp2 <- NA
if(ineFP1.res$value>p.level){
ineFP1.int1 <- function(delta){
fun.ineFP1t1 <- function(x){
refstd <- 1.5*sd.ref
indt <- ( abs(x[1]-x[2])<=refstd )*( abs(x[1]-x[3])<=delta )*( abs(x[2]-x[3])<=refstd )
fxyz <- dnorm(x[1], mean = mean.data[1], sd = sd.ref/sqrt(n))*
dt(sqrt(n)*(x[2]-mean.data[2])/sd.data[2],df=n-1)*
dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*n^(2/2)/prod(sd.data[2:3])*indt
return(fxyz)
}
return(cuhre(NDIM, NCOMP, fun.ineFP1t1, lower=c(intmar.l[1],intmar.l.ie[2:3]), upper=c(intmar.u[1],intmar.u.ie[2:3]), flags= list(verbose=0, final=0))$value)
}
rcd.simuCI2.tmp2 <- uniroot(function(delta) ineFP1.int1(delta)-p.level, lower = 0, upper = 1.5*sd.ref)$root
}
ineFP1.int2 <- function(delta){
fun.ineFP1t2 <- function(x){
indt <- ( abs(x[1]-x[2])<=delta )*( abs(x[1]-x[3])<=delta )*( abs(x[2]-x[3])<=delta )
fxyz <- dnorm(x[1], mean = mean.data[1], sd = sd.ref/sqrt(n))*
dt(sqrt(n)*(x[2]-mean.data[2])/sd.data[2],df=n-1)*
dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*n^(2/2)/prod(sd.data[2:3])*indt
return(fxyz)
}
return(cuhre(NDIM, NCOMP, fun.ineFP1t2, lower=c(intmar.l[1],intmar.l.ie[2:3]), upper=c(intmar.u[1],intmar.u.ie[2:3]), flags= list(verbose=0, final=0))$value)
}
rcd.simuCI2.tmp3 <- uniroot(function(delta) ineFP1.int2(delta)-p.level, lower = 0, upper = 20*sd.ref)$root
# 2.2.2 Integrated version, suppose population sd unknown and follow an inversed chisq distribution
fun.ineFP1.int <- function(x){
refstd <- 1.5*x[4]
indt <- ( abs(x[1]-x[2])<=refstd )*( abs(x[1]-x[3])<=refstd )*( abs(x[2]-x[3])<=refstd )
fxyzu <- dnorm(x[1], mean = mean.data[1], sd = x[4]/sqrt(n))*
dt(sqrt(n)*(x[2]-mean.data[2])/sd.data[2],df=n-1)*
dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*
n^(2/2)/prod(sd.data[2:3])*indt* (2*x[4]^(-3)*(n-1)*sd.ref^2)*
dchisq((n-1)*sd.ref^2/(x[4]^2), df=n-1)
return(fxyzu)
}
ineFP1.res.mod <- cuhre(NDIM+1, NCOMP, fun.ineFP1.int, lower=c(intmar.l.int[1],intmar.l.ie[2:3],0), upper=c(intmar.u.int[1],intmar.u.ie[2:3],intmarv), flags= list(verbose=0, final=0))
rcd.simuCI2.tmp4 <- ineFP1.res.mod$value
rcd.simuCI2.tmp5 <- NA
if(ineFP1.res.mod$value>p.level){
ineFP1.int1.mod <- function(delta){
fun.ineFP1t1.mod <- function(x){
refstd <- 1.5*x[4]
indt <- ( abs(x[1]-x[2])<=refstd )*( abs(x[1]-x[3])<=delta*refstd )*( abs(x[2]-x[3])<=refstd )
fxyzu <- dnorm(x[1], mean = mean.data[1], sd = x[4]/sqrt(n))*
dt(sqrt(n)*(x[2]-mean.data[2])/sd.data[2],df=n-1)*
dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*
n^(2/2)/prod(sd.data[2:3])*indt* (2*x[4]^(-3)*(n-1)*sd.ref^2)*
dchisq((n-1)*sd.ref^2/(x[4]^2), df=n-1)
return(fxyzu)
}
return(cuhre(NDIM+1, NCOMP, fun.ineFP1t1.mod, lower=c(intmar.l.int[1],intmar.l.ie[2:3],0), upper=c(intmar.u.int[1],intmar.u.ie[2:3],intmarv), flags= list(verbose=0, final=0))$value)
}
rcd.simuCI2.tmp5 <- uniroot(function(delta) ineFP1.int1.mod(delta)-p.level, lower = 0, upper = 1)$root
}
ineFP1.int2.mod <- function(delta){
fun.ineFP1t2.mod <- function(x){
refstd <- 1.5*x[4]
indt <- ( abs(x[1]-x[2])<=delta*refstd )*( abs(x[1]-x[3])<=delta*refstd )*( abs(x[2]-x[3])<=delta*refstd )
fxyzu <- dnorm(x[1], mean = mean.data[1], sd = x[4]/sqrt(n))*
dt(sqrt(n)*(x[2]-mean.data[2])/sd.data[2],df=n-1)*
dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*n^(2/2)/prod(sd.data[2:3])*indt*
(2*x[4]^(-3)*(n-1)*sd.ref^2)*
dchisq((n-1)*sd.ref^2/(x[4]^2), df=n-1)
return(fxyzu)
}
return(cuhre(NDIM+1, NCOMP, fun.ineFP1t2.mod, lower=c(intmar.l.int[1],intmar.l.ie[2:3],0), upper=c(intmar.u.int[1],intmar.u.ie[2:3],intmarv), flags= list(verbose=0, final=0))$value)
}
rcd.simuCI2.tmp6 <- uniroot(function(delta) ineFP1.int2.mod(delta)-p.level, lower = 0, upper = 20)$root
# 2.2.3 Least favorable version, suppose population sd take the lower bound of the inversed chisq distribution
fun.ineFP1.lf <- function(x){
refstd <- 1.5*sd.ref.lf
indt <- ( abs(x[1]-x[2])<=refstd )*( abs(x[1]-x[3])<=refstd )*( abs(x[2]-x[3])<=refstd )
fxyz <- dnorm(x[1], mean = mean.data[1], sd = sd.ref.lf/sqrt(n))*
dt(sqrt(n)*(x[2]-mean.data[2])/sd.data[2],df=n-1)*
dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*n^(2/2)/prod(sd.data[2:3])*indt
return(fxyz)
}
ineFP1.res.lf <- cuhre(NDIM, NCOMP, fun.ineFP1.lf, lower=c(intmar.l.lf[1],intmar.l.ie[2:3]), upper=c(intmar.u.lf[1],intmar.u.ie[2:3]), flags= list(verbose=0, final=0))
rcd.simuCI2.tmp7 <- ineFP1.res.lf$value
rcd.simuCI2.tmp8 <- NA
if(ineFP1.res.lf$value>p.level){
ineFP1.int1.lf <- function(delta){
fun.ineFP1t1.lf <- function(x){
refstd <- 1.5*sd.ref.lf
indt <- ( abs(x[1]-x[2])<=refstd )*( abs(x[1]-x[3])<=delta )*( abs(x[2]-x[3])<=refstd )
fxyz <- dnorm(x[1], mean = mean.data[1], sd = sd.ref.lf/sqrt(n))*dt(sqrt(n)*(x[2]-mean.data[2])/sd.data[2],df=n-1)*dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*n^(2/2)/prod(sd.data[2:3])*indt
return(fxyz)
}
return(cuhre(NDIM, NCOMP, fun.ineFP1t1.lf, lower=c(intmar.l.lf[1],intmar.l.ie[2:3]), upper=c(intmar.u.lf[1],intmar.u.ie[2:3]), flags= list(verbose=0, final=0))$value)
}
rcd.simuCI2.tmp8 <- uniroot(function(delta) ineFP1.int1.lf(delta)-p.level, lower = 0, upper = 1.5*sd.ref.lf)$root
}
ineFP1.int2.lf <- function(delta){
fun.ineFP1t2.lf <- function(x){
indt <- ( abs(x[1]-x[2])<=delta )*( abs(x[1]-x[3])<=delta )*( abs(x[2]-x[3])<=delta )
fxyz <- dnorm(x[1], mean = mean.data[1], sd = sd.ref.lf/sqrt(n))*dt(sqrt(n)*(x[2]-mean.data[2])/sd.data[2],df=n-1)*dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*n^(2/2)/prod(sd.data[2:3])*indt
return(fxyz)
}
return(cuhre(NDIM, NCOMP, fun.ineFP1t2.lf, lower=c(intmar.l.lf[1],intmar.l.ie[2:3]), upper=c(intmar.u.lf[1],intmar.u.ie[2:3]), flags= list(verbose=0, final=0))$value)
}
rcd.simuCI2.tmp9 <- uniroot(function(delta) ineFP1.int2.lf(delta)-p.level, lower = 0, upper = 20*sd.ref.lf)$root
# 2.3 Without the assumption of equal variances, two reference (use sd.ref and sd.ref1 to calculate similarity margin: refstd=1.5*sd.ref, refstd2=1.5*sd.ref2)
# 2.3.1 Original version, sd.ref as true population sd
fun.ine2FP1 <- function(x){
refstd <- 1.5*sd.ref
refstd2 <- 1.5*sd.ref2
indt <- ( abs(x[1]-x[2])<=refstd )*( abs(x[1]-x[3])<=refstd )*( abs(x[2]-x[3])<=refstd2 )
fxyz <- dnorm(x[1], mean = mean.data[1], sd = sd.ref/sqrt(n))*dnorm(x[2], mean = mean.data[2], sd = sd.ref2/sqrt(n))*dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*n^(1/2)/prod(sd.data[3])*indt
return(fxyz)
}
ine2FP1.res <- cuhre(NDIM, NCOMP, fun.ine2FP1, lower=c(intmar.l2[1:2],intmar.l.ie[3]), upper=c(intmar.u2[1:2],intmar.u.ie[3]), flags= list(verbose=0, final=0))
rcd.simuCI3.tmp1 <- ine2FP1.res$value
rcd.simuCI3.tmp2 <- NA
if(ine2FP1.res$value>p.level){
ine2FP1.int1 <- function(delta){
fun.ine2FP1t1 <- function(x){
refstd <- 1.5*sd.ref
refstd2 <- 1.5*sd.ref2
indt <- ( abs(x[1]-x[2])<=refstd )*( abs(x[1]-x[3])<=delta )*( abs(x[2]-x[3])<=refstd2 )
fxyz <- dnorm(x[1], mean = mean.data[1], sd = sd.ref/sqrt(n))*dnorm(x[2], mean = mean.data[2], sd = sd.ref2/sqrt(n))*dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*n^(1/2)/prod(sd.data[3])*indt
return(fxyz)
}
return(cuhre(NDIM, NCOMP, fun.ine2FP1t1, lower=c(intmar.l2[1:2],intmar.l.ie[3]), upper=c(intmar.u2[1:2],intmar.u.ie[3]), flags= list(verbose=0, final=0))$value)
}
rcd.simuCI3.tmp2 <- uniroot(function(delta) ine2FP1.int1(delta)-p.level, lower = 0, upper = 1.5*sd.ref)$root
}
ine2FP1.int2 <- function(delta){
fun.ine2FP1t2 <- function(x){
refstd <- 1.5*sd.ref
refstd2 <- 1.5*sd.ref2
indt <- ( abs(x[1]-x[2])<=delta*refstd )*( abs(x[1]-x[3])<=delta*refstd )*( abs(x[2]-x[3])<=delta*refstd2 )
fxyz <- dnorm(x[1], mean = mean.data[1], sd = sd.ref/sqrt(n))*dnorm(x[2], mean = mean.data[2], sd = sd.ref2/sqrt(n))*dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*n^(1/2)/prod(sd.data[3])*indt
return(fxyz)
}
return(cuhre(NDIM, NCOMP, fun.ine2FP1t2, lower=c(intmar.l2[1:2],intmar.l.ie[3]), upper=c(intmar.u2[1:2],intmar.u.ie[3]), flags= list(verbose=0, final=0))$value)
}
rcd.simuCI3.tmp3 <- uniroot(function(delta) ine2FP1.int2(delta)-p.level, lower = 0, upper = 20)$root
# 2.3.2 Integrated version, suppose population sd unknown and follow an inversed chisq distribution
fun.ine2FP1.int <- function(x){
refstd <- 1.5*x[4]
refstd2 <- 1.5*x[5]
indt <- ( abs(x[1]-x[2])<=refstd )*( abs(x[1]-x[3])<=refstd )*( abs(x[2]-x[3])<=refstd2 )
fxyzu <- dnorm(x[1], mean = mean.data[1], sd = x[4]/sqrt(n))*dnorm(x[2], mean = mean.data[2], sd = x[5]/sqrt(n))*dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*n^(1/2)/prod(sd.data[3])*indt* (2*x[4]^(-3)*(n-1)*sd.ref^2)*dchisq((n-1)*sd.ref^2/(x[4]^2), df=n-1)* (2*x[5]^(-3)*(n-1)*sd.ref2^2)*dchisq((n-1)*sd.ref2^2/(x[5]^2), df=n-1)
return(fxyzu)
}
ine2FP1.res.mod <- cuhre(NDIM+2, NCOMP, fun.ine2FP1.int, lower=c(intmar.l.int2[1:2],intmar.l.ie[3],0,0), upper=c(intmar.u.int2[1:2],intmar.u.ie[3],c(intmarv1t,intmarv2t)), flags= list(verbose=0, final=0))
rcd.simuCI3.tmp4 <- ine2FP1.res.mod$value
rcd.simuCI3.tmp5 <- NA
if(ine2FP1.res.mod$value>p.level){
ine2FP1.int1.mod <- function(delta){
fun.ine2FP1t1.mod <- function(x){
refstd <- 1.5*x[4]
refstd2 <- 1.5*x[5]
indt <- ( abs(x[1]-x[2])<=refstd )*( abs(x[1]-x[3])<=delta*refstd )*( abs(x[2]-x[3])<=refstd2 )
fxyzu <- dnorm(x[1], mean = mean.data[1], sd = x[4]/sqrt(n))*dnorm(x[2], mean = mean.data[2], sd = x[5]/sqrt(n))*dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*n^(1/2)/prod(sd.data[3])*indt* (2*x[4]^(-3)*(n-1)*sd.ref^2)*dchisq((n-1)*sd.ref^2/(x[4]^2), df=n-1)* (2*x[5]^(-3)*(n-1)*sd.ref2^2)*dchisq((n-1)*sd.ref2^2/(x[5]^2), df=n-1)
return(fxyzu)
}
return(cuhre(NDIM+2, NCOMP, fun.ine2FP1t1.mod, lower=c(intmar.l.int2[1:2],intmar.l.ie[3],0,0), upper=c(intmar.u.int2[1:2],intmar.u.ie[3],c(intmarv1t,intmarv2t)), flags= list(verbose=0, final=0))$value)
}
rcd.simuCI3.tmp5 <- uniroot(function(delta) ine2FP1.int1.mod(delta)-p.level, lower = 0, upper = 1)$root
}
ine2FP1.int2.mod <- function(delta){
fun.ine2FP1t2.mod <- function(x){
refstd <- 1.5*x[4]
refstd2 <- 1.5*x[5]
indt <- ( abs(x[1]-x[2])<=delta*refstd )*( abs(x[1]-x[3])<=delta*refstd )*( abs(x[2]-x[3])<=delta*refstd2 )
# indt <- 1
fxyzu <- dnorm(x[1], mean = mean.data[1], sd = x[4]/sqrt(n))*dnorm(x[2], mean = mean.data[2], sd = x[5]/sqrt(n))*dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*n^(1/2)/prod(sd.data[3])*indt* (2*x[4]^(-3)*(n-1)*sd.ref^2)*dchisq((n-1)*sd.ref^2/(x[4]^2), df=n-1)* (2*x[5]^(-3)*(n-1)*sd.ref2^2)*dchisq((n-1)*sd.ref2^2/(x[5]^2), df=n-1)
return(fxyzu)
}
return(cuhre(NDIM+2, NCOMP, fun.ine2FP1t2.mod, lower=c(intmar.l.int2[1:2],intmar.l.ie[3],0,0), upper=c(intmar.u.int2[1:2],intmar.u.ie[3],c(intmarv1t,intmarv2t)), flags= list(verbose=0, final=0))$value)
}
rcd.simuCI3.tmp6 <- uniroot(function(delta) ine2FP1.int2.mod(delta)-p.level, lower = 0, upper = 20)$root
# 2.3.3 Least favorable version, suppose population sd take the lower bound of the inversed chisq distribution
fun.ine2FP1.lf <- function(x){
refstd1 <- 1.5*sd.ref.lf1
refstd2 <- 1.5*sd.ref.lf2
indt <- ( abs(x[1]-x[2])<=refstd1 )*( abs(x[1]-x[3])<=refstd1 )*( abs(x[2]-x[3])<=refstd2 )
fxyz <- dnorm(x[1], mean = mean.data[1], sd = sd.ref.lf1/sqrt(n))*dnorm(x[2], mean = mean.data[2], sd = sd.ref.lf2/sqrt(n))*dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*n^(1/2)/prod(sd.data[3])*indt
return(fxyz)
}
ine2FP1.res.lf <- cuhre(NDIM, NCOMP, fun.ine2FP1.lf, lower=c(intmar.l2.lf[1:2],intmar.l.ie[3]), upper=c(intmar.u2.lf[1:2],intmar.u.ie[3]), flags= list(verbose=0, final=0))
rcd.simuCI3.tmp7 <- ine2FP1.res.lf$value
rcd.simuCI3.tmp8 <- NA
if(ine2FP1.res.lf$value>p.level){
ine2FP1.int1.lf <- function(delta){
fun.ine2FP1t1.lf <- function(x){
refstd1 <- 1.5*sd.ref.lf1
refstd2 <- 1.5*sd.ref.lf2
indt <- ( abs(x[1]-x[2])<=refstd1 )*( abs(x[1]-x[3])<=delta )*( abs(x[2]-x[3])<=refstd2 )
fxyz <- dnorm(x[1], mean = mean.data[1], sd = sd.ref.lf1/sqrt(n))*dnorm(x[2], mean = mean.data[2], sd = sd.ref.lf2/sqrt(n))*dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*n^(1/2)/prod(sd.data[3])*indt
return(fxyz)
}
return(cuhre(NDIM, NCOMP, fun.ine2FP1t1.lf, lower=c(intmar.l2.lf[1:2],intmar.l.ie[3]), upper=c(intmar.u2.lf[1:2],intmar.u.ie[3]), flags= list(verbose=0, final=0))$value)
}
rcd.simuCI3.tmp8 <- uniroot(function(delta) ine2FP1.int1.lf(delta)-p.level, lower = 0, upper = 1.5*sd.ref.lf1)$root
}
ine2FP1.int2.lf <- function(delta){
fun.ine2FP1t2.lf <- function(x){
refstd1 <- 1.5*sd.ref.lf1
refstd2 <- 1.5*sd.ref.lf2
indt <- ( abs(x[1]-x[2])<=delta*refstd1 )*( abs(x[1]-x[3])<=delta*refstd1 )*( abs(x[2]-x[3])<=delta*refstd2 )
fxyz <- dnorm(x[1], mean = mean.data[1], sd = sd.ref.lf1/sqrt(n))*dnorm(x[2], mean = mean.data[2], sd = sd.ref.lf2/sqrt(n))*dt(sqrt(n)*(x[3]-mean.data[3])/sd.data[3],df=n-1)*n^(1/2)/prod(sd.data[3])*indt
return(fxyz)
}
return(cuhre(NDIM, NCOMP, fun.ine2FP1t2.lf, lower=c(intmar.l2.lf[1:2],intmar.l.ie[3]), upper=c(intmar.u2.lf[1:2],intmar.u.ie[3]), flags= list(verbose=0, final=0))$value)
}
rcd.simuCI3.tmp9 <- uniroot(function(delta) ine2FP1.int2.lf(delta)-p.level, lower = 0, upper = 20)$root
# ---------------- combine data and results: n*5, 3+5+3, 9+9+9 ---------------
results <- c(rcd.data.tmp,
rcd.mean.tmp,
rcd.std.tmp,
rcd.sig.tmp,
rcd.simuCI1.tmp1,
rcd.simuCI1.tmp2,
rcd.simuCI1.tmp3,
rcd.simuCI1.tmp4,
rcd.simuCI1.tmp5,
rcd.simuCI1.tmp6,
rcd.simuCI1.tmp7,
rcd.simuCI1.tmp8,
rcd.simuCI1.tmp9,
rcd.simuCI2.tmp1,
rcd.simuCI2.tmp2,
rcd.simuCI2.tmp3,
rcd.simuCI2.tmp4,
rcd.simuCI2.tmp5,
rcd.simuCI2.tmp6,
rcd.simuCI2.tmp7,
rcd.simuCI2.tmp8,
rcd.simuCI2.tmp9,
rcd.simuCI3.tmp1,
rcd.simuCI3.tmp2,
rcd.simuCI3.tmp3,
rcd.simuCI3.tmp4,
rcd.simuCI3.tmp5,
rcd.simuCI3.tmp6,
rcd.simuCI3.tmp7,
rcd.simuCI3.tmp8,
rcd.simuCI3.tmp9
)
return(results)
}
system.time(out.tmp.cont <- sapply(1:repet, simu.one.PAR.mpi, k=k,mu.R1=mu.R1,mu.R2=mu.R2,mu.T=mu.T,n=n))
#   clusterExport(cl, varlist=c("k","rsd21","rsdT1","mu.R1","mu.R2","mu.T","sd.all","n"), envir=environment())
#
#   system.time(out.tmp.cont <- parSapply(cl, 1:repet, simu.one.PAR.mpi, k=k,rsd21=rsd21,rsdT1=rsdT1,mu.R1=mu.R1,mu.R2=mu.R2,mu.T=mu.T,sd.all=sd.all,n=n))
#
#
restmp <- t(out.tmp.cont)
rcd.data <- restmp[,1:(n*5)]
rcd.mean <- restmp[,(n*5+1):(n*5+3)]
rcd.std <- restmp[,(n*5+3+1):(n*5+3+5)]
rcd.sig <- restmp[,(n*5+3+5+1):(n*5+3+5+3)]
rcd.simuCI1 <- restmp[,(n*5+3+5+3+1):(n*5+3+5+3+9)]
rcd.simuCI2 <- restmp[,(n*5+3+5+3+9+1):(n*5+3+5+3+9+9)]
rcd.simuCI3 <- restmp[,(n*5+3+5+3+9+9+1):(n*5+3+5+3+9+9+9)]
Arcd.data[,(n*5*(k-1)+1):(n*5*k)] <- rcd.data
Arcd.mean[,(3*(k-1)+1):(3*k)] <- rcd.mean
Arcd.std[,((3+2)*(k-1)+1):((3+2)*k)] <- rcd.std
Arcd.sig[,(3*(k-1)+1):(3*k)] <- rcd.sig
Arcd.simuCI1[,(9*(k-1)+1):(9*k)] <- rcd.simuCI1
Arcd.simuCI2[,(9*(k-1)+1):(9*k)] <- rcd.simuCI2
Arcd.simuCI3[,(9*(k-1)+1):(9*k)] <- rcd.simuCI3
summ.sig[k,] <- c(apply(rcd.sig,2,mean), sum(apply(rcd.sig[,2:3],1,prod))/repet, sum(apply(rcd.sig,1,prod))/repet)
summ.simuCI1[k,] <- c(mean(rcd.simuCI1[,1]),
mean(rcd.simuCI1[,1]>=p.level),
mean(rcd.simuCI1[,2]/rcd.std[,4], na.rm=T),
mean(rcd.simuCI1[,2]/rcd.std[,4]>=true1T, na.rm=T),
mean(rcd.simuCI1[,3]/rcd.std[,4]),
mean(rcd.simuCI1[,3]/rcd.std[,4]>=max(true1T,true2T,true12)),
mean(rcd.simuCI1[,4]),
mean(rcd.simuCI1[,4]>=p.level),
mean(rcd.simuCI1[,5]*1.5, na.rm=T),
mean(rcd.simuCI1[,5]*1.5>=true1T, na.rm=T),
mean(rcd.simuCI1[,6]*1.5),
mean(rcd.simuCI1[,6]*1.5>=max(true1T,true2T,true12)),
mean(rcd.simuCI1[,7]),
mean(rcd.simuCI1[,7]>=p.level),
mean(rcd.simuCI1[,8]/rcd.std[,4], na.rm=T),
mean(rcd.simuCI1[,8]/rcd.std[,4]>=true1T, na.rm=T),
mean(rcd.simuCI1[,9]/rcd.std[,4]),
mean(rcd.simuCI1[,9]/rcd.std[,4]>=max(true1T,true2T,true12))
)
summ.simuCI2[k,] <- c(mean(rcd.simuCI2[,1]),
mean(rcd.simuCI2[,1]>=p.level),
mean(rcd.simuCI2[,2]/rcd.std[,4], na.rm=T),
mean(rcd.simuCI2[,2]/rcd.std[,4]>=true1T, na.rm=T),
mean(rcd.simuCI2[,3]/rcd.std[,4]),
mean(rcd.simuCI2[,3]/rcd.std[,4]>=max(true1T,true2T,true12)),
mean(rcd.simuCI2[,4]),
mean(rcd.simuCI2[,4]>=p.level),
mean(rcd.simuCI2[,5]*1.5, na.rm=T),
mean(rcd.simuCI2[,5]*1.5>=true1T, na.rm=T),
mean(rcd.simuCI2[,6]*1.5),
mean(rcd.simuCI2[,6]*1.5>=max(true1T,true2T,true12)),
mean(rcd.simuCI2[,7]),
mean(rcd.simuCI2[,7]>=p.level),
mean(rcd.simuCI2[,8]/rcd.std[,4], na.rm=T),
mean(rcd.simuCI2[,8]/rcd.std[,4]>=true1T, na.rm=T),
mean(rcd.simuCI2[,9]/rcd.std[,4]),
mean(rcd.simuCI2[,9]/rcd.std[,4]>=max(true1T,true2T,true12))
)
summ.simuCI3[k,] <- c(mean(rcd.simuCI3[,1]),
mean(rcd.simuCI3[,1]>=p.level),
mean(rcd.simuCI3[,2]/rcd.std[,4], na.rm=T),
mean(rcd.simuCI3[,2]/rcd.std[,4]>=true1T, na.rm=T),
mean(rcd.simuCI3[,3]*1.5),
mean(rcd.simuCI3[,3]*1.5>=max(true1T,true2T.2,true12)),
mean(rcd.simuCI3[,4]),
mean(rcd.simuCI3[,4]>=p.level),
mean(rcd.simuCI3[,5]*1.5, na.rm=T),
mean(rcd.simuCI3[,5]*1.5>=true1T, na.rm=T),
mean(rcd.simuCI3[,6]*1.5),
mean(rcd.simuCI3[,6]*1.5>=max(true1T,true2T.2,true12)),
mean(rcd.simuCI3[,7]),
mean(rcd.simuCI3[,7]>=p.level),
mean(rcd.simuCI3[,8]/rcd.std[,4], na.rm=T),
mean(rcd.simuCI3[,8]/rcd.std[,4]>=true1T, na.rm=T),
mean(rcd.simuCI3[,9]*1.5),
mean(rcd.simuCI3[,9]*1.5>=max(true1T,true2T.2,true12))
)
}
Arcd <- cbind(Arcd.data, Arcd.mean, Arcd.std, Arcd.sig, Arcd.simuCI1, Arcd.simuCI2, Arcd.simuCI3)
summ <- round(cbind(summ.sig, summ.simuCI1, summ.simuCI2, summ.simuCI3),3)
rundate <- c("0625")
write.csv(Arcd, paste("Arcd_n",n,"_",mu.R1,"_",mu.R2,"_",mu.T,"_r_",rsd21,"_",rsdT1,"_sdR1_",round(sd.all[1],2),"_",round(sd.all[ksce],2),"_rp",repet,"_",rundate,"_v2.csv",sep=""))
write.csv(summ, paste("summ_n",n,"_",mu.R1,"_",mu.R2,"_",mu.T,"_r_",rsd21,"_",rsdT1,"_sdR1_",round(sd.all[1],2),"_",round(sd.all[ksce],2),"_rp",repet,"_",rundate,"_v2.csv",sep=""))
# stopCluster(cl)
rm(list = ls())
setwd("M:/")
rm(list=ls())
library(ggplot2)
library(gridExtra)
setwd("//fda.gov/wodc/CDER/Users05/Donglei.Yin/Result")
filename='n10_0_2_1_equal_var__sdR1_1.33_12_rp1000_0627_v2'
simu_result<-read.csv(paste0("./summ_",filename, ".csv"),header=T)[,-1]
dim(simu_result)
colnames(simu_result)<-c("Pair_R1_R2","Pair_R1_T","Pair_R2_T","Pair_23","Pair_123",
"Orig_FP","Orig_Power","Orig_CI1_D","Orig_CI1_CR","Orig_CI2_D","Orig_CI2_CR",
"Inte_FP","Inte_Power","Inte_CI1_D","Inte_CI1_CR","Inte_CI2_D","Inte_CI2_CR",
"LF_FP","LF_Power","LF_CI1_D","LF_CI1_CR","LF_CI2_D","LF_CI2_CR")
table(simu_result$Orig_CI1_CR)
sum(!is.na(simu_result$Orig_CI1_CR))
sum(!is.na(simu_result$Orig_CI2_CR))
sum(!is.na(simu_result$Inte_CI1_CR))
sum(!is.na(simu_result$Inte_CI2_CR))
sum(!is.na(simu_result$LF_CI1_CR))
sum(!is.na(simu_result$LF_CI1_CR))
rm(list=ls())
library(ggplot2)
library(gridExtra)
filename='n10_0_2_1_equal_var__sdR1_1.33_12_rp1000_0627_v2'
simu_result<-read.csv(paste0("./Arcd_",filename, ".csv"),header=T)[,-1]
dim(simu_result)
colnames(simu_result)<-c("Pair_R1_R2","Pair_R1_T","Pair_R2_T","Pair_23","Pair_123",
"Orig_FP","Orig_Power","Orig_CI1_D","Orig_CI1_CR","Orig_CI2_D","Orig_CI2_CR",
"Inte_FP","Inte_Power","Inte_CI1_D","Inte_CI1_CR","Inte_CI2_D","Inte_CI2_CR",
"LF_FP","LF_Power","LF_CI1_D","LF_CI1_CR","LF_CI2_D","LF_CI2_CR")
sum(!is.na(simu_result$Orig_CI1_CR))
table(simu_result$Orig_CI1_CR)
dim(simu_result)
View(simu_result)
View(simu_result)
k
dim(Arcd.simuCI1)
7*9
563-55
63-55
dim(simu_result)
temp<-simu_result[,483:490]
temp<-simu_result[,482:490]
sum(is.na(temp[,483]))
sum(is.na(temp[,2]))
sum(is.na(temp[,3]))
sum(!is.na(temp[,2]))
sum(is.na(temp[,2]))
sum(is.na(temp[,3]))
sum(is.na(temp[,5]))
sum(is.na(temp[,6]))
sum(is.na(temp[,7]))
sum(is.na(temp[,8]))
